# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Account {
  address: String!
  id: ID!
  name: String!
}

type City {
  country: Country!
  id: ID!
  name: String!
  state: State!
}

type Comment {
  commentAccount: Account!
  commentAccountId: Int
  commentByPublicKey: String
  commentText: String!
  commentTo: Post!
  commentToId: String!
  content: String!

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!
  id: ID!
  lotusBurnDown: Float!
  lotusBurnScore: Float!
  lotusBurnUp: Float!

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime!
}

type CommentConnection {
  edges: [CommentEdge!]
  pageInfo: PageInfo!
  totalCount: Int
}

type CommentEdge {
  cursor: String!
  node: Comment!
}

input CommentOrder {
  direction: OrderDirection!
  field: CommentOrderField!
}

"""Properties by which comment connections can be ordered."""
enum CommentOrderField {
  createdAt
  id
  lotusBurnScore
  updatedAt
}

type Country {
  capital: String!
  city: [City!]!
  id: ID!
  name: String!
  state: [State!]!
}

input CreateCommentInput {
  commentByPublicKey: String
  commentText: String!
  commentToId: String!
  tipHex: String
}

input CreatePageInput {
  categoryId: String
  description: String!
  name: String!
}

input CreatePostInput {
  htmlContent: String!
  pageAccountId: Int
  pageId: String
  pureContent: String!
  tokenPrimaryId: String
  uploadCovers: [String!]
}

input CreateTokenInput {
  tokenId: String!
}

input CreateWorshipInput {
  latitude: Decimal
  location: String
  longitude: Decimal
  worshipedAmount: Float!
  worshipedPersonId: String!
}

input CreateWorshipedPersonInput {
  avatar: String
  bio: String
  cityId: String
  countryId: String
  dateOfBirth: String
  dateOfDeath: String
  name: String!
  quote: String
  stateId: String
  wikiDataId: String
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

"""An arbitrary-precision Decimal type"""
scalar Decimal

type Mutation {
  createComment(data: CreateCommentInput!): Comment!
  createPage(data: CreatePageInput!): Page!
  createPost(data: CreatePostInput!): Post!
  createToken(data: CreateTokenInput!): Token!
  createWorship(data: CreateWorshipInput!): Worship!
  createWorshipedPerson(data: CreateWorshipedPersonInput!): WorshipedPerson!
  updatePage(data: UpdatePageInput!): Page!
  updatePost(data: UpdatePostInput!): Post!
}

"""
Possible directions in which to order a list of items when provided an `orderBy` argument.
"""
enum OrderDirection {
  asc
  desc
}

type Page {
  address: String
  avatar: String
  categoryId: String
  countryId: String
  cover: String

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!
  description: String!
  id: ID!
  lotusBurnDown: Float!
  lotusBurnScore: Float!
  lotusBurnUp: Float!
  name: String!
  pageAccountId: Int!
  parent: Page
  parentId: String
  stateId: String
  title: String

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime!
  website: String
}

type PageConnection {
  edges: [PageEdge!]
  pageInfo: PageInfo!
  totalCount: Int
}

type PageEdge {
  cursor: String!
  node: Page!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input PageOrder {
  direction: OrderDirection!
  field: PageOrderField!
}

"""Properties by which page connections can be ordered."""
enum PageOrderField {
  createdAt
  id
  lotusBurnScore
  name
  title
  updatedAt
}

type Post {
  content: String!

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!
  id: ID!
  lotusBurnDown: Float!
  lotusBurnScore: Float!
  lotusBurnUp: Float!
  page: Page
  pageAccount: Account
  pageAccountId: Int
  pageId: String
  postAccount: Account!
  postAccountId: Int!
  token: Token
  tokenId: String
  totalComments: Int!

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime!
  uploads: [UploadDetail!]
}

type PostConnection {
  edges: [PostEdge!]
  pageInfo: PageInfo!
  totalCount: Int
}

type PostEdge {
  cursor: String!
  node: Post!
}

type PostMeiliEdge {
  cursor: String
  node: Post
}

type PostMeiliPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input PostOrder {
  direction: OrderDirection!
  field: PostOrderField!
}

"""Properties by which post connections can be ordered."""
enum PostOrderField {
  content
  createdAt
  id
  lotusBurnScore
  updatedAt
}

type PostResponse {
  edges: [PostMeiliEdge!]
  pageInfo: PostMeiliPageInfo
}

type Query {
  allCommentsToPostId(after: String, before: String, first: Int, id: String, last: Int, minBurnFilter: Int, orderBy: CommentOrder, skip: Int): CommentConnection!
  allOrphanPosts(after: String, before: String, first: Int, last: Int, minBurnFilter: Int, orderBy: PostOrder, query: String, skip: Int): PostConnection!
  allPages(after: String, before: String, first: Int, last: Int, minBurnFilter: Int, orderBy: PageOrder, query: String, skip: Int): PageConnection!
  allPosts(after: String, before: String, first: Int, last: Int, minBurnFilter: Int, orderBy: PostOrder, query: String, skip: Int): PostConnection!
  allPostsByPageId(after: String, before: String, first: Int, id: String, last: Int, minBurnFilter: Int, orderBy: PostOrder, skip: Int): PostConnection!
  allPostsBySearch(
    """Paginate after opaque cursor"""
    after: String

    """Paginate before opaque cursor"""
    before: String

    """Paginate first"""
    first: Int

    """Paginate last"""
    last: Int
    minBurnFilter: Int
    query: String
  ): PostResponse!
  allPostsByTokenId(after: String, before: String, first: Int, id: String, last: Int, minBurnFilter: Int, orderBy: PostOrder, skip: Int): PostConnection!
  allPostsByUserId(after: String, before: String, first: Int, id: String, last: Int, minBurnFilter: Int, orderBy: PostOrder, skip: Int): PostConnection!
  allTokens(after: String, before: String, first: Int, last: Int, minBurnFilter: Int, orderBy: TokenOrder, query: String, skip: Int): TokenConnection!
  allWorship(after: String, before: String, first: Int, last: Int, minBurnFilter: Int, orderBy: WorshipOrder, skip: Int): WorshipConnection!
  allWorshipedByPersonId(after: String, before: String, first: Int, id: String, last: Int, minBurnFilter: Int, orderBy: WorshipOrder, skip: Int): WorshipConnection!
  allWorshipedPerson(after: String, before: String, first: Int, last: Int, minBurnFilter: Int, orderBy: WorshipedPersonOrder, skip: Int): WorshipedPersonConnection!
  allWorshipedPersonBySearch(
    """Paginate after opaque cursor"""
    after: String

    """Paginate before opaque cursor"""
    before: String

    """Paginate first"""
    first: Int

    """Paginate last"""
    last: Int
    query: String
  ): WorshipedPersonConnection!
  allWorshipedPersonByUserId(after: String, before: String, first: Int, last: Int, minBurnFilter: Int, orderBy: WorshipedPersonOrder, skip: Int): WorshipedPersonConnection!
  allWorshipedPersonSpecialDate(after: String, before: String, first: Int, last: Int, minBurnFilter: Int, orderBy: WorshipedPersonOrder, skip: Int): WorshipedPersonConnection!
  comment(id: String!): Comment!
  page(id: String!): Page!
  post(id: String!): Post!
  token(tokenId: String!): Token!
  worship(id: String!): Worship!
  worshipedPerson(id: String!): WorshipedPerson!
}

type State {
  city: [City!]!
  country: City!
  id: ID!
  name: String!
}

type Subscription {
  commentCreated: Comment!
  pageCreated: Page!
  postCreated: Post!
  tokenCreated: Token!
  worshipedPersonCreated: WorshipedPerson!
}

type Token {
  """Identifies the date and time when the object was last comments."""
  comments: DateTime

  """Identifies the date and time when the object was created."""
  createdDate: DateTime!
  decimals: Int!
  id: ID!
  initialTokenQuantity: String
  lotusBurnDown: Float!
  lotusBurnScore: Float!
  lotusBurnUp: Float!
  name: String!
  ticker: String!
  tokenDocumentUrl: String
  tokenId: String!
  tokenType: String!
  totalBurned: String
  totalMinted: String
}

type TokenConnection {
  edges: [TokenEdge!]
  pageInfo: PageInfo!
  totalCount: Int
}

type TokenEdge {
  cursor: String!
  node: Token!
}

input TokenOrder {
  direction: OrderDirection!
  field: TokenOrderField!
}

"""Properties by which token connections can be ordered."""
enum TokenOrderField {
  createdDate
  id
  lotusBurnDown
  lotusBurnScore
  lotusBurnUp
  name
  ticker
  tokenId
}

input UpdatePageInput {
  address: String
  avatar: String
  categoryId: String
  countryId: String
  cover: String
  description: String
  id: ID!
  name: String
  parentId: String
  stateId: String
  title: String
  website: String
}

input UpdatePostInput {
  htmlContent: String!
  id: ID!
  pureContent: String!
}

type Upload {
  bucket: String
  height: String
  id: ID!
  sha: String!
  sha40: String
  sha320: String
  sha800: String
  width: String
}

type UploadDetail {
  id: ID!
  upload: Upload!
}

type Worship {
  account: Account!

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!
  id: ID!
  latitude: Decimal
  location: String
  longitude: Decimal

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime!
  worshipedAmount: Float!
  worshipedPerson: WorshipedPerson!
}

type WorshipConnection {
  edges: [WorshipEdge!]
  pageInfo: PageInfo!
  totalCount: Int
}

type WorshipEdge {
  cursor: String!
  node: Worship!
}

input WorshipOrder {
  direction: OrderDirection!
  field: WorshipOrderField!
}

"""Properties by which worship connections can be ordered."""
enum WorshipOrderField {
  createdAt
  id
  updatedAt
  worshipedAmount
}

type WorshipedPerson {
  achievement: String
  alias: String
  avatar: UploadDetail
  bio: String
  city: City
  country: Country
  countryOfCitizenship: String

  """Identifies the date and time when the object was created."""
  createdAt: DateTime
  dateOfBirth: DateTime
  dateOfDeath: DateTime
  id: ID!
  name: String!
  placeOfBirth: String
  placeOfBurial: String
  placeOfDeath: String
  quote: String
  religion: String
  state: State
  totalWorshipAmount: Int

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime
  wikiAvatar: String
  wikiDataId: String
}

type WorshipedPersonConnection {
  edges: [WorshipedPersonEdge!]
  pageInfo: PageInfo!
  totalCount: Int
}

type WorshipedPersonEdge {
  cursor: String!
  node: WorshipedPerson!
}

input WorshipedPersonOrder {
  direction: OrderDirection!
  field: WorshipedPersonOrderField!
}

"""Properties by which worshiped person connections can be ordered."""
enum WorshipedPersonOrderField {
  createdAt
  id
  totalWorshipAmount
  updatedAt
}