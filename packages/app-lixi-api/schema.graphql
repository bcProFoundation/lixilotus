# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Account {
  address: String!
  id: ID!
  name: String!
}

type Comment {
  commentAccount: Account!
  commentAccountId: Int
  commentByPublicKey: String
  commentText: String!
  commentTo: Post!
  commentToId: String!
  content: String!

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!
  id: ID!
  lotusBurnDown: Float!
  lotusBurnScore: Float!
  lotusBurnUp: Float!

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime!
}

type CommentConnection {
  edges: [CommentEdge!]
  pageInfo: PageInfo!
  totalCount: Int
}

type CommentEdge {
  cursor: String!
  node: Comment!
}

input CommentOrder {
  direction: OrderDirection!
  field: CommentOrderField!
}

"""Properties by which comment connections can be ordered."""
enum CommentOrderField {
  createdAt
  id
  lotusBurnScore
  updatedAt
}

input CreateCommentInput {
  commentByPublicKey: String
  commentText: String!
  commentToId: String!
  tipHex: String
}

input CreatePageInput {
  address: String!
  avatar: String!
  country: String!
  cover: String!
  description: String!
  name: String!
  parentId: String
  state: String!
  title: String!
  website: String!
}

input CreatePostInput {
  htmlContent: String!
  pageAccountId: Int
  pageId: String
  pureContent: String!
  tokenPrimaryId: String
  uploadCovers: [String!]
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type Mutation {
  createComment(data: CreateCommentInput!): Comment!
  createPage(data: CreatePageInput!): Page!
  createPost(data: CreatePostInput!): Post!
  updatePage(data: UpdatePageInput!): Page!
}

"""
Possible directions in which to order a list of items when provided an `orderBy` argument.
"""
enum OrderDirection {
  asc
  desc
}

type Page {
  address: String
  avatar: String
  country: String
  cover: String

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!
  description: String!
  id: ID!
  lotusBurnDown: Float!
  lotusBurnScore: Float!
  lotusBurnUp: Float!
  name: String!
  pageAccountId: Int!
  parent: Page
  parentId: String
  state: String
  title: String!

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime!
  website: String
}

type PageConnection {
  edges: [PageEdge!]
  pageInfo: PageInfo!
  totalCount: Int
}

type PageEdge {
  cursor: String!
  node: Page!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input PageOrder {
  direction: OrderDirection!
  field: PageOrderField!
}

"""Properties by which page connections can be ordered."""
enum PageOrderField {
  createdAt
  id
  lotusBurnScore
  name
  title
  updatedAt
}

type Post {
  content: String!

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!
  id: ID!
  lotusBurnDown: Float!
  lotusBurnScore: Float!
  lotusBurnUp: Float!
  page: Page
  pageAccount: Account
  pageAccountId: Int
  pageId: String
  postAccount: Account!
  postAccountId: Int!
  token: Token
  tokenId: String

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime!
  uploads: [UploadDetail!]
}

type PostConnection {
  edges: [PostEdge!]
  pageInfo: PageInfo!
  totalCount: Int
}

type PostEdge {
  cursor: String!
  node: Post!
}

type PostMeiliEdge {
  cursor: String
  node: Post
}

type PostMeiliPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input PostOrder {
  direction: OrderDirection!
  field: PostOrderField!
}

"""Properties by which post connections can be ordered."""
enum PostOrderField {
  content
  createdAt
  id
  lotusBurnScore
  updatedAt
}

type PostResponse {
  edges: [PostMeiliEdge!]
  pageInfo: PostMeiliPageInfo
}

type Query {
  allCommentsToPostId(after: String, before: String, first: Int, id: String, last: Int, orderBy: CommentOrder, skip: Int): CommentConnection!
  allOrphanPosts(after: String, before: String, first: Int, last: Int, orderBy: PostOrder, query: String, skip: Int): PostConnection!
  allPages(after: String, before: String, first: Int, last: Int, orderBy: PageOrder, query: String, skip: Int): PageConnection!
  allPosts(after: String, before: String, first: Int, last: Int, orderBy: PostOrder, query: String, skip: Int): PostConnection!
  allPostsByPageId(after: String, before: String, first: Int, id: String, last: Int, orderBy: PostOrder, skip: Int): PostConnection!
  allPostsBySearch(
    """Paginate after opaque cursor"""
    after: String

    """Paginate before opaque cursor"""
    before: String

    """Paginate first"""
    first: Int

    """Paginate last"""
    last: Int
    query: String
  ): PostResponse!
  allPostsByTokenId(after: String, before: String, first: Int, id: String, last: Int, orderBy: PostOrder, skip: Int): PostConnection!
  allPostsByUserId(after: String, before: String, first: Int, id: String, last: Int, orderBy: PostOrder, skip: Int): PostConnection!
  comment(id: String!): Comment!
  page(id: String!): Page!
  post(id: String!): Post!
}

type Subscription {
  commentCreated: Comment!
  pageCreated: Page!
  postCreated: Post!
}

type Token {
  """Identifies the date and time when the object was last comments."""
  comments: DateTime

  """Identifies the date and time when the object was created."""
  createdDate: DateTime!
  decimals: Int!
  id: ID!
  initialTokenQuantity: String
  lotusBurnDown: Float!
  lotusBurnScore: Float!
  lotusBurnUp: Float!
  name: String!
  ticker: String!
  tokenDocumentUrl: String
  tokenId: String!
  tokenType: String!
  totalBurned: String
  totalMinted: String
}

type TokenEdge {
  cursor: String!
  node: Token!
}

input UpdatePageInput {
  address: String
  avatar: String
  country: String
  cover: String
  description: String
  id: ID!
  name: String
  parentId: String
  state: String
  title: String!
  website: String
}

type Upload {
  bucket: String
  id: ID!
  sha: String!
}

type UploadDetail {
  id: ID!
  upload: Upload!
}