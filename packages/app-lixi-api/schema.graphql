# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Account {
  address: String!
  balance: Int!

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!
  encryptedMnemonic: String
  encryptedSecret: String
  followersCount: Int
  followingPagesCount: Int
  followingsCount: Int
  id: ID!
  language: String!
  mnemonic: String
  mnemonicHash: String
  name: String!
  pages: [Page!]
  publicKey: String
  secret: String

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime!
}

type AccountEdge {
  cursor: String!
  node: Account!
}

type City {
  country: Country!
  id: ID!
  name: String!
  state: State!
}

type Comment {
  commentAccount: Account!
  commentAccountId: Int
  commentByPublicKey: String
  commentText: String!
  commentTo: Post!
  commentToId: String!
  content: String!

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!
  id: ID!
  lotusBurnDown: Float!
  lotusBurnScore: Float!
  lotusBurnUp: Float!

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime!
}

type CommentConnection {
  edges: [CommentEdge!]
  pageInfo: PageInfo!
  totalCount: Int
}

type CommentEdge {
  cursor: String!
  node: Comment!
}

input CommentOrder {
  direction: OrderDirection!
  field: CommentOrderField!
}

"""Properties by which comment connections can be ordered."""
enum CommentOrderField {
  createdAt
  id
  lotusBurnScore
  updatedAt
}

type Country {
  capital: String!
  city: [City!]!
  id: ID!
  name: String!
  state: [State!]!
}

input CreateAccountInput {
  encryptedMnemonic: String!
  language: String!
  mnemonic: String!
  mnemonicHash: String!
}

input CreateCommentInput {
  commentByPublicKey: String
  commentText: String!
  commentToId: String!
  tipHex: String
}

input CreateFollowAccountInput {
  followerAccountId: Int!
  followingAccountId: Int!
}

input CreateFollowPageInput {
  accountId: Int!
  pageId: String!
}

input CreatePageInput {
  categoryId: String
  description: String!
  name: String!
}

input CreatePostInput {
  htmlContent: String!
  pageAccountId: Int
  pageId: String
  pureContent: String!
  tokenPrimaryId: String
  uploadCovers: [String!]
}

input CreateTempleInput {
  achievement: String
  address: String
  alias: String
  avatar: String
  cityId: String
  countryId: String
  cover: String
  dateOfCompleted: DateTime
  description: String
  name: String!
  president: String
  religion: String
  stateId: String
  website: String
}

input CreateTokenInput {
  tokenId: String!
}

input CreateWorshipInput {
  latitude: Decimal
  location: String
  longitude: Decimal
  templeId: String
  worshipedAmount: Float!
  worshipedPersonId: String
}

input CreateWorshipedPersonInput {
  avatar: String
  bio: String
  cityId: String
  countryId: String
  dateOfBirth: String
  dateOfDeath: String
  name: String!
  quote: String
  stateId: String
  wikiDataId: String
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

"""An arbitrary-precision Decimal type"""
scalar Decimal

input DeleteFollowAccountInput {
  followerAccountId: Int!
  followingAccountId: Int!
}

input DeleteFollowPageInput {
  accountId: Int!
  pageId: String!
}

type FollowAccount {
  """Identifies the date and time when the object was created."""
  createdAt: DateTime!
  followerAccount: Account
  followerAccountId: Int
  followingAccount: Account
  followingAccountId: Int
  id: ID
  isFollowed: Boolean

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime!
}

type FollowAccountConnection {
  edges: [FollowAccountEdge!]
  pageInfo: PageInfo!
  totalCount: Int
}

type FollowAccountEdge {
  cursor: String!
  node: FollowAccount!
}

input FollowAccountOrder {
  direction: OrderDirection!
  field: FollowAccountOrderField!
}

"""Properties by which follow account connections can be ordered."""
enum FollowAccountOrderField {
  createdAt
  followerAccountId
  followingAccountId
  id
  updatedAt
}

type FollowPage {
  account: Account
  accountId: Int

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!
  id: ID
  isFollowed: Boolean
  page: Page
  pageId: String

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime!
}

type FollowPageEdge {
  cursor: String!
  node: FollowPage!
}

type Hashtag {
  content: String!

  """Identifies the date and time when the object was created."""
  createdAt: DateTime
  id: ID!
  lotusBurnDown: Float!
  lotusBurnScore: Float!
  lotusBurnUp: Float!
  postHashtags: [PostHashtag!]

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime
}

type HashtagConnection {
  edges: [HashtagEdge!]
  pageInfo: PageInfo!
  totalCount: Int
}

type HashtagEdge {
  cursor: String!
  node: Hashtag!
}

input HashtagOrder {
  direction: OrderDirection!
  field: HashtagOrderField!
}

"""Properties by which hashtag connections can be ordered."""
enum HashtagOrderField {
  createdAt
  id
  lotusBurnScore
  updatedAt
}

input ImportAccountInput {
  language: String
  mnemonic: String!
  mnemonicHash: String
}

type Mutation {
  createAccount(data: CreateAccountInput!): Account!
  createComment(data: CreateCommentInput!): Comment!
  createFollowAccount(data: CreateFollowAccountInput!): FollowAccount!
  createFollowPage(data: CreateFollowPageInput!): FollowPage!
  createPage(data: CreatePageInput!): Page!
  createPost(data: CreatePostInput!): Post!
  createTemple(data: CreateTempleInput!): Temple!
  createToken(data: CreateTokenInput!): Token!
  createWorship(data: CreateWorshipInput!): Worship!
  createWorshipTemple(data: CreateWorshipInput!): Worship!
  createWorshipedPerson(data: CreateWorshipedPersonInput!): WorshipedPerson!
  deleteFollowAccount(data: DeleteFollowAccountInput!): Boolean!
  deleteFollowPage(data: DeleteFollowPageInput!): Boolean!
  importAccount(data: ImportAccountInput!): Account!
  updatePage(data: UpdatePageInput!): Page!
  updatePost(data: UpdatePostInput!): Post!
}

"""
Possible directions in which to order a list of items when provided an `orderBy` argument.
"""
enum OrderDirection {
  asc
  desc
}

type Page {
  address: String
  avatar: String
  categoryId: String
  countryId: String
  cover: String

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!
  description: String!
  encryptedMnemonic: String
  followersCount: Int
  id: ID!
  lotusBurnDown: Float!
  lotusBurnScore: Float!
  lotusBurnUp: Float!
  name: String!
  pageAccount: Account!
  pageAccountId: Int!
  parent: Page
  parentId: String
  salt: String
  stateId: String
  title: String

  """The sum of burn amount for every post on page"""
  totalBurnForPage: Float

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime!
  website: String
}

type PageConnection {
  edges: [PageEdge!]
  pageInfo: PageInfo!
  totalCount: Int
}

type PageEdge {
  cursor: String!
  node: Page!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input PageOrder {
  direction: OrderDirection!
  field: PageOrderField!
}

"""Properties by which page connections can be ordered."""
enum PageOrderField {
  createdAt
  id
  lotusBurnScore
  name
  title
  updatedAt
}

type Post {
  content: String!

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!
  id: ID!
  lotusBurnDown: Float!
  lotusBurnScore: Float!
  lotusBurnUp: Float!
  page: Page
  pageId: String
  postAccount: Account!
  postAccountId: Int!
  postHashtags: [PostHashtag!]
  token: Token
  tokenId: String
  totalComments: Int!

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime!
  uploads: [UploadDetail!]
}

type PostConnection {
  edges: [PostEdge!]
  pageInfo: PageInfo!
  totalCount: Int
}

type PostEdge {
  cursor: String!
  node: Post!
}

type PostHashtag {
  """Identifies the date and time when the object was created."""
  createdAt: DateTime
  hashtag: Hashtag!
  hashtagId: String!
  id: ID!
  post: Post
  postId: String

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime
}

type PostMeiliEdge {
  cursor: String
  node: Post
}

type PostMeiliPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input PostOrder {
  direction: OrderDirection!
  field: PostOrderField!
}

"""Properties by which post connections can be ordered."""
enum PostOrderField {
  content
  createdAt
  id
  lotusBurnScore
  updatedAt
}

type PostResponse {
  edges: [PostMeiliEdge!]
  pageInfo: PostMeiliPageInfo
}

type Query {
  allCommentsToPostId(after: String, before: String, first: Int, id: String, last: Int, minBurnFilter: Int, orderBy: CommentOrder, skip: Int): CommentConnection!
  allFollowersByFollowing(after: String, before: String, first: Int, followingAccountId: Int, last: Int, minBurnFilter: Int, orderBy: FollowAccountOrder, skip: Int): FollowAccountConnection!
  allFollowingsByFollower(after: String, before: String, first: Int, followerAccountId: Int, last: Int, minBurnFilter: Int, orderBy: FollowAccountOrder, skip: Int): FollowAccountConnection!
  allHashtag(after: String, before: String, first: Int, last: Int, minBurnFilter: Int, orderBy: HashtagOrder, skip: Int): HashtagConnection!
  allHashtagBySearch(
    """Paginate after opaque cursor"""
    after: String

    """Paginate before opaque cursor"""
    before: String

    """Paginate first"""
    first: Int

    """Paginate last"""
    last: Int
    query: String
  ): HashtagConnection!
  allOrphanPosts(after: String, before: String, first: Int, last: Int, minBurnFilter: Int, orderBy: PostOrder, query: String, skip: Int): PostConnection!
  allPages(after: String, before: String, first: Int, last: Int, minBurnFilter: Int, orderBy: PageOrder, query: String, skip: Int): PageConnection!
  allPagesByUserId(after: String, before: String, first: Int, id: Int, last: Int, minBurnFilter: Int, orderBy: PageOrder, skip: Int): PageConnection!
  allPosts(accountId: Int, after: String, before: String, first: Int, last: Int, minBurnFilter: Int, orderBy: PostOrder, skip: Int): PostConnection!
  allPostsByHashtag(after: String, before: String, first: Int, id: String, last: Int, minBurnFilter: Int, orderBy: PostOrder, skip: Int): PostConnection!
  allPostsByPageId(after: String, before: String, first: Int, id: String, last: Int, minBurnFilter: Int, orderBy: PostOrder, skip: Int): PostConnection!
  allPostsBySearch(
    """Paginate after opaque cursor"""
    after: String

    """Paginate before opaque cursor"""
    before: String

    """Paginate first"""
    first: Int

    """Paginate last"""
    last: Int
    minBurnFilter: Int
    query: String
  ): PostResponse!
  allPostsByTokenId(after: String, before: String, first: Int, id: String, last: Int, minBurnFilter: Int, orderBy: PostOrder, skip: Int): PostConnection!
  allPostsByUserId(after: String, before: String, first: Int, id: String, last: Int, minBurnFilter: Int, orderBy: PostOrder, skip: Int): PostConnection!
  allTemple(after: String, before: String, first: Int, last: Int, minBurnFilter: Int, orderBy: TempleOrder, skip: Int): TempleConnection!
  allTempleBySearch(
    """Paginate after opaque cursor"""
    after: String

    """Paginate before opaque cursor"""
    before: String

    """Paginate first"""
    first: Int

    """Paginate last"""
    last: Int
    query: String
  ): TempleConnection!
  allTokens(after: String, before: String, first: Int, last: Int, minBurnFilter: Int, orderBy: TokenOrder, query: String, skip: Int): TokenConnection!
  allWorship(after: String, before: String, first: Int, last: Int, minBurnFilter: Int, orderBy: WorshipOrder, skip: Int): WorshipConnection!
  allWorshipedByPersonId(after: String, before: String, first: Int, id: String, last: Int, minBurnFilter: Int, orderBy: WorshipOrder, skip: Int): WorshipConnection!
  allWorshipedByTempleId(after: String, before: String, first: Int, id: String, last: Int, minBurnFilter: Int, orderBy: WorshipOrder, skip: Int): WorshipConnection!
  allWorshipedPerson(after: String, before: String, first: Int, last: Int, minBurnFilter: Int, orderBy: WorshipedPersonOrder, skip: Int): WorshipedPersonConnection!
  allWorshipedPersonBySearch(
    """Paginate after opaque cursor"""
    after: String

    """Paginate before opaque cursor"""
    before: String

    """Paginate first"""
    first: Int

    """Paginate last"""
    last: Int
    query: String
  ): WorshipedPersonConnection!
  allWorshipedPersonByUserId(after: String, before: String, first: Int, last: Int, minBurnFilter: Int, orderBy: WorshipedPersonOrder, skip: Int): WorshipedPersonConnection!
  allWorshipedPersonSpecialDate(after: String, before: String, first: Int, last: Int, minBurnFilter: Int, orderBy: WorshipedPersonOrder, skip: Int): WorshipedPersonConnection!
  checkIsFollowedAccount(address: String!): FollowAccount!
  checkIsFollowedPage(pageId: String!): FollowPage!
  comment(id: String!): Comment!
  getAccountByAddress(address: String!): Account!
  hashtag(id: String!): Hashtag!
  page(id: String!): Page!
  post(id: String!): Post!
  temple(id: String!): Temple!
  token(tokenId: String!): Token!
  worship(id: String!): Worship!
  worshipedPerson(id: String!): WorshipedPerson!
}

type State {
  city: [City!]!
  country: City!
  id: ID!
  name: String!
}

type Subscription {
  accountCreated: Account!
  commentCreated: Comment!
  followAccountCreated: FollowAccount!
  hashtagCreated: Hashtag!
  pageCreated: Page!
  postCreated: Post!
  templeCreated: Temple!
  tokenCreated: Token!
  worshipedPersonCreated: WorshipedPerson!
}

type Temple {
  account: Account!
  achievement: String
  address: String
  alias: String
  avatar: UploadDetail
  city: City
  country: Country
  cover: UploadDetail

  """Identifies the date and time when the object was created."""
  createdAt: DateTime
  dateOfCompleted: DateTime
  description: String
  id: ID!
  name: String!
  president: String
  religion: String
  state: State
  totalWorshipAmount: Int

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime
  verified: Boolean!
  website: String
}

type TempleConnection {
  edges: [TempleEdge!]
  pageInfo: PageInfo!
  totalCount: Int
}

type TempleEdge {
  cursor: String!
  node: Temple!
}

input TempleOrder {
  direction: OrderDirection!
  field: TempleOrderField!
}

"""Properties by which temple connections can be ordered."""
enum TempleOrderField {
  createdAt
  id
  totalWorshipAmount
  updatedAt
}

type Token {
  """Identifies the date and time when the object was last comments."""
  comments: DateTime

  """Identifies the date and time when the object was created."""
  createdDate: DateTime!
  decimals: Int!
  id: ID!
  initialTokenQuantity: String
  lotusBurnDown: Float!
  lotusBurnScore: Float!
  lotusBurnUp: Float!
  name: String!
  ticker: String!
  tokenDocumentUrl: String
  tokenId: String!
  tokenType: String!
  totalBurned: String
  totalMinted: String
}

type TokenConnection {
  edges: [TokenEdge!]
  pageInfo: PageInfo!
  totalCount: Int
}

type TokenEdge {
  cursor: String!
  node: Token!
}

input TokenOrder {
  direction: OrderDirection!
  field: TokenOrderField!
}

"""Properties by which token connections can be ordered."""
enum TokenOrderField {
  createdDate
  id
  lotusBurnDown
  lotusBurnScore
  lotusBurnUp
  name
  ticker
  tokenId
}

input UpdatePageInput {
  address: String
  avatar: String
  categoryId: String
  countryId: String
  cover: String
  description: String
  id: ID!
  name: String
  parentId: String
  stateId: String
  title: String
  website: String
}

input UpdatePostInput {
  htmlContent: String!
  id: ID!
  pureContent: String!
}

type Upload {
  bucket: String
  height: String
  id: ID!
  sha: String!
  sha40: String
  sha320: String
  sha800: String
  width: String
}

type UploadDetail {
  id: ID!
  upload: Upload!
}

type Worship {
  account: Account!

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!
  id: ID!
  latitude: Decimal
  location: String
  longitude: Decimal
  temple: Temple

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime!
  worshipedAmount: Float!
  worshipedPerson: WorshipedPerson
}

type WorshipConnection {
  edges: [WorshipEdge!]
  pageInfo: PageInfo!
  totalCount: Int
}

type WorshipEdge {
  cursor: String!
  node: Worship!
}

input WorshipOrder {
  direction: OrderDirection!
  field: WorshipOrderField!
}

"""Properties by which worship connections can be ordered."""
enum WorshipOrderField {
  createdAt
  id
  updatedAt
  worshipedAmount
}

type WorshipedPerson {
  achievement: String
  alias: String
  avatar: UploadDetail
  bio: String
  city: City
  country: Country
  countryOfCitizenship: String

  """Identifies the date and time when the object was created."""
  createdAt: DateTime
  dateOfBirth: DateTime
  dateOfDeath: DateTime
  id: ID!
  name: String!
  placeOfBirth: String
  placeOfBurial: String
  placeOfDeath: String
  quote: String
  religion: String
  state: State
  totalWorshipAmount: Int

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime
  wikiAvatar: String
  wikiDataId: String
}

type WorshipedPersonConnection {
  edges: [WorshipedPersonEdge!]
  pageInfo: PageInfo!
  totalCount: Int
}

type WorshipedPersonEdge {
  cursor: String!
  node: WorshipedPerson!
}

input WorshipedPersonOrder {
  direction: OrderDirection!
  field: WorshipedPersonOrderField!
}

"""Properties by which worshiped person connections can be ordered."""
enum WorshipedPersonOrderField {
  createdAt
  id
  totalWorshipAmount
  updatedAt
}