/* eslint-disable */ /**
  *
  * THIS FILE IS AUTOGENERATED, DO NOT EDIT IT!
  *
  * instead, edit one of the `.graphql` files in this project and run
  *
  * yarn graphql-codegen
  *
  * for this file to be re-created
  */

import * as Types from '../../generated/types.generated';

import { PageInfoFieldsFragmentDoc } from '../../graphql/fragments/page-info-fields.fragment.generated';
import { api } from 'src/api/baseApi';
export type PostQueryVariables = Types.Exact<{
  id: Types.Scalars['String'];
}>;


export type PostQuery = { __typename?: 'Query', post: { __typename?: 'Post', id: string, content: string, uploadCovers?: Array<string> | null, lotusBurnUp: number, lotusBurnDown: number, createdAt: any, updatedAt: any, postAccount: { __typename?: 'Account', address: string, id: string, name: string }, pageAccount: { __typename?: 'Account', address: string, id: string, name: string }, page?: { __typename?: 'Page', avatar?: string | null, name: string, id: string } | null } };

export type PostsQueryVariables = Types.Exact<{
  after?: Types.InputMaybe<Types.Scalars['String']>;
  before?: Types.InputMaybe<Types.Scalars['String']>;
  first?: Types.InputMaybe<Types.Scalars['Int']>;
  last?: Types.InputMaybe<Types.Scalars['Int']>;
  orderBy?: Types.InputMaybe<Types.PostOrder>;
  query?: Types.InputMaybe<Types.Scalars['String']>;
  skip?: Types.InputMaybe<Types.Scalars['Int']>;
}>;


export type PostsQuery = { __typename?: 'Query', allPosts: { __typename?: 'PostConnection', totalCount?: number | null, edges?: Array<{ __typename?: 'PostEdge', cursor: string, node: { __typename?: 'Post', id: string, content: string, uploadCovers?: Array<string> | null, lotusBurnUp: number, lotusBurnDown: number, createdAt: any, updatedAt: any, postAccount: { __typename?: 'Account', address: string, id: string, name: string }, pageAccount: { __typename?: 'Account', address: string, id: string, name: string }, page?: { __typename?: 'Page', avatar?: string | null, name: string, id: string } | null } }> | null, pageInfo: { __typename?: 'PageInfo', endCursor?: string | null, hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null } } };

export type PostsByPageIdQueryVariables = Types.Exact<{
  after?: Types.InputMaybe<Types.Scalars['String']>;
  before?: Types.InputMaybe<Types.Scalars['String']>;
  first?: Types.InputMaybe<Types.Scalars['Int']>;
  last?: Types.InputMaybe<Types.Scalars['Int']>;
  orderBy?: Types.InputMaybe<Types.PostOrder>;
  id?: Types.InputMaybe<Types.Scalars['String']>;
  skip?: Types.InputMaybe<Types.Scalars['Int']>;
}>;


export type PostsByPageIdQuery = { __typename?: 'Query', allPostsByPageId: { __typename?: 'PostConnection', totalCount?: number | null, edges?: Array<{ __typename?: 'PostEdge', cursor: string, node: { __typename?: 'Post', id: string, content: string, uploadCovers?: Array<string> | null, lotusBurnUp: number, lotusBurnDown: number, createdAt: any, updatedAt: any, postAccount: { __typename?: 'Account', address: string, id: string, name: string }, pageAccount: { __typename?: 'Account', address: string, id: string, name: string }, page?: { __typename?: 'Page', avatar?: string | null, name: string, id: string } | null } }> | null, pageInfo: { __typename?: 'PageInfo', endCursor?: string | null, hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null } } };

export type PostFieldsFragment = { __typename?: 'Post', id: string, content: string, uploadCovers?: Array<string> | null, lotusBurnUp: number, lotusBurnDown: number, createdAt: any, updatedAt: any, postAccount: { __typename?: 'Account', address: string, id: string, name: string }, pageAccount: { __typename?: 'Account', address: string, id: string, name: string }, page?: { __typename?: 'Page', avatar?: string | null, name: string, id: string } | null };

export type CreatePostMutationVariables = Types.Exact<{
  input: Types.CreatePostInput;
}>;


export type CreatePostMutation = { __typename?: 'Mutation', createPost: { __typename?: 'Post', id: string, content: string, uploadCovers?: Array<string> | null, lotusBurnUp: number, lotusBurnDown: number, createdAt: any, updatedAt: any, postAccount: { __typename?: 'Account', address: string, id: string, name: string }, pageAccount: { __typename?: 'Account', address: string, id: string, name: string }, page?: { __typename?: 'Page', avatar?: string | null, name: string, id: string } | null } };

export type UpdatePostMutationVariables = Types.Exact<{
  input: Types.UpdatePostInput;
}>;


export type UpdatePostMutation = { __typename?: 'Mutation', updatePost: { __typename?: 'Post', id: string, content: string, uploadCovers?: Array<string> | null, lotusBurnUp: number, lotusBurnDown: number, createdAt: any, updatedAt: any, postAccount: { __typename?: 'Account', address: string, id: string, name: string }, pageAccount: { __typename?: 'Account', address: string, id: string, name: string }, page?: { __typename?: 'Page', avatar?: string | null, name: string, id: string } | null } };

export const PostFieldsFragmentDoc = `
    fragment PostFields on Post {
  id
  content
  uploadCovers
  postAccount {
    address
    id
    name
  }
  pageAccount {
    address
    id
    name
  }
  page {
    avatar
    name
    id
  }
  lotusBurnUp
  lotusBurnDown
  createdAt
  updatedAt
}
    `;
export const PostDocument = `
    query Post($id: String!) {
  post(id: $id) {
    ...PostFields
  }
}
    ${PostFieldsFragmentDoc}`;
export const PostsDocument = `
    query Posts($after: String, $before: String, $first: Int = 20, $last: Int, $orderBy: PostOrder, $query: String, $skip: Int) {
  allPosts(
    after: $after
    before: $before
    first: $first
    last: $last
    orderBy: $orderBy
    query: $query
    skip: $skip
  ) {
    totalCount
    edges {
      cursor
      node {
        ...PostFields
      }
    }
    pageInfo {
      ...PageInfoFields
    }
  }
}
    ${PostFieldsFragmentDoc}
${PageInfoFieldsFragmentDoc}`;
export const PostsByPageIdDocument = `
    query PostsByPageId($after: String, $before: String, $first: Int = 20, $last: Int, $orderBy: PostOrder, $id: String, $skip: Int) {
  allPostsByPageId(
    after: $after
    before: $before
    first: $first
    last: $last
    orderBy: $orderBy
    id: $id
    skip: $skip
  ) {
    totalCount
    edges {
      cursor
      node {
        ...PostFields
      }
    }
    pageInfo {
      ...PageInfoFields
    }
  }
}
    ${PostFieldsFragmentDoc}
${PageInfoFieldsFragmentDoc}`;
export const CreatePostDocument = `
    mutation createPost($input: CreatePostInput!) {
  createPost(data: $input) {
    ...PostFields
  }
}
    ${PostFieldsFragmentDoc}`;
export const UpdatePostDocument = `
    mutation updatePost($input: UpdatePostInput!) {
  updatePost(data: $input) {
    ...PostFields
  }
}
    ${PostFieldsFragmentDoc}`;

const injectedRtkApi = api.injectEndpoints({
  endpoints: (build) => ({
    Post: build.query<PostQuery, PostQueryVariables>({
      query: (variables) => ({ document: PostDocument, variables })
    }),
    Posts: build.query<PostsQuery, PostsQueryVariables | void>({
      query: (variables) => ({ document: PostsDocument, variables })
    }),
    PostsByPageId: build.query<PostsByPageIdQuery, PostsByPageIdQueryVariables | void>({
      query: (variables) => ({ document: PostsByPageIdDocument, variables })
    }),
    createPost: build.mutation<CreatePostMutation, CreatePostMutationVariables>({
      query: (variables) => ({ document: CreatePostDocument, variables })
    }),
    updatePost: build.mutation<UpdatePostMutation, UpdatePostMutationVariables>({
      query: (variables) => ({ document: UpdatePostDocument, variables })
    }),
  }),
});

export { injectedRtkApi as api };
export const { usePostQuery, useLazyPostQuery, usePostsQuery, useLazyPostsQuery, usePostsByPageIdQuery, useLazyPostsByPageIdQuery, useCreatePostMutation, useUpdatePostMutation } = injectedRtkApi;

